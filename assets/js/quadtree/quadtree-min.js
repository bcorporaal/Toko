class Point{constructor(t,s,e){this.x=t,this.y=s,this.userData=e}sqDistanceFrom(t){const s=t.x-this.x,e=t.y-this.y;return s*s+e*e}distanceFrom(t){return Math.sqrt(this.sqDistanceFrom(t))}}class Rectangle{constructor(t,s,e,i,h){this.x=t,this.y=s,this.w=e,this.h=i,this.left=t-e/2,this.right=t+e/2,this.top=s-i/2,this.bottom=s+i/2}contains(t){return this.left<=t.x&&t.x<=this.right&&this.top<=t.y&&t.y<=this.bottom}intersects(t){return!(this.right<t.left||t.right<this.left||this.bottom<t.top||t.bottom<this.top)}subdivide(t){switch(t){case"ne":return new Rectangle(this.x+this.w/4,this.y-this.h/4,this.w/2,this.h/2);case"nw":return new Rectangle(this.x-this.w/4,this.y-this.h/4,this.w/2,this.h/2);case"se":return new Rectangle(this.x+this.w/4,this.y+this.h/4,this.w/2,this.h/2);case"sw":return new Rectangle(this.x-this.w/4,this.y+this.h/4,this.w/2,this.h/2)}}xDistanceFrom(t){return this.left<=t.x&&t.x<=this.right?0:Math.min(Math.abs(t.x-this.left),Math.abs(t.x-this.right))}yDistanceFrom(t){return this.top<=t.y&&t.y<=this.bottom?0:Math.min(Math.abs(t.y-this.top),Math.abs(t.y-this.bottom))}sqDistanceFrom(t){const s=this.xDistanceFrom(t),e=this.yDistanceFrom(t);return s*s+e*e}distanceFrom(t){return Math.sqrt(this.sqDistanceFrom(t))}}class Circle{constructor(t,s,e){this.x=t,this.y=s,this.r=e,this.rSquared=this.r*this.r}contains(t){return Math.pow(t.x-this.x,2)+Math.pow(t.y-this.y,2)<=this.rSquared}intersects(t){let s=Math.abs(t.x-this.x),e=Math.abs(t.y-this.y),i=this.r,h=t.w/2,n=t.h/2,r=Math.pow(s-h,2)+Math.pow(e-n,2);return!(s>i+h||e>i+n)&&(s<=h||e<=n||r<=this.rSquared)}}class QuadTree{DEFAULT_CAPACITY=8;MAX_DEPTH=8;constructor(t,s=this.DEFAULT_CAPACITY,e=0){if(!t)throw TypeError("boundary is null or undefined");if(!(t instanceof Rectangle))throw TypeError("boundary should be a Rectangle");if("number"!=typeof s)throw TypeError("capacity should be a number but is a "+typeof s);if(s<1)throw RangeError("capacity must be greater than 0");this.boundary=t,this.capacity=s,this.points=[],this.divided=!1,this.depth=e}get children(){return this.divided?[this.northeast,this.northwest,this.southeast,this.southwest]:[]}clear(){this.points=[],this.divided&&(this.divided=!1,delete this.northwest,delete this.northeast,delete this.southwest,delete this.southeast)}static create(){if(0===arguments.length){if("undefined"==typeof width)throw new TypeError("No global width defined");if("undefined"==typeof height)throw new TypeError("No global height defined");let t=new Rectangle(width/2,height/2,width,height);return new QuadTree(t,this.DEFAULT_CAPACITY)}if(arguments[0]instanceof Rectangle){let t=arguments[1]||this.DEFAULT_CAPACITY;return new QuadTree(arguments[0],t)}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]&&"number"==typeof arguments[2]&&"number"==typeof arguments[3]){let t=arguments[4]||this.DEFAULT_CAPACITY;return new QuadTree(new Rectangle(arguments[0],arguments[1],arguments[2],arguments[3]),t)}throw new TypeError("Invalid parameters")}toJSON(){let t={};return this.divided?((this.northeast.divided||this.northeast.points.length>0)&&(t.ne=this.northeast.toJSON()),(this.northwest.divided||this.northwest.points.length>0)&&(t.nw=this.northwest.toJSON()),(this.southeast.divided||this.southeast.points.length>0)&&(t.se=this.southeast.toJSON()),(this.southwest.divided||this.southwest.points.length>0)&&(t.sw=this.southwest.toJSON())):t.points=this.points,0===this.depth&&(t.capacity=this.capacity,t.x=this.boundary.x,t.y=this.boundary.y,t.w=this.boundary.w,t.h=this.boundary.h),t}static fromJSON(t,s,e,i,h,n,r){if(void 0===s){if(!("x"in t))throw TypeError("JSON missing boundary information");s=t.x,e=t.y,i=t.w,h=t.h,n=t.capacity,r=0}let o=new QuadTree(new Rectangle(s,e,i,h),n,r);if(o.points=t.points??null,o.divided=null===o.points,"ne"in t||"nw"in t||"se"in t||"sw"in t){const s=o.boundary.x,e=o.boundary.y,i=o.boundary.w/2,h=o.boundary.h/2;o.northeast="ne"in t?QuadTree.fromJSON(t.ne,s+i/2,e-h/2,i,h,n,r+1):new QuadTree(o.boundary.subdivide("ne"),n,r+1),o.northwest="nw"in t?QuadTree.fromJSON(t.nw,s-i/2,e-h/2,i,h,n,r+1):new QuadTree(o.boundary.subdivide("nw"),n,r+1),o.southeast="se"in t?QuadTree.fromJSON(t.se,s+i/2,e+h/2,i,h,n,r+1):new QuadTree(o.boundary.subdivide("se"),n,r+1),o.southwest="sw"in t?QuadTree.fromJSON(t.sw,s-i/2,e+h/2,i,h,n,r+1):new QuadTree(o.boundary.subdivide("sw"),n,r+1)}return o}subdivide(){this.northeast=new QuadTree(this.boundary.subdivide("ne"),this.capacity,this.depth+1),this.northwest=new QuadTree(this.boundary.subdivide("nw"),this.capacity,this.depth+1),this.southeast=new QuadTree(this.boundary.subdivide("se"),this.capacity,this.depth+1),this.southwest=new QuadTree(this.boundary.subdivide("sw"),this.capacity,this.depth+1),this.divided=!0;for(const t of this.points){if(!(this.northeast.insert(t)||this.northwest.insert(t)||this.southeast.insert(t)||this.southwest.insert(t)))throw RangeError("capacity must be greater than 0")}this.points=null}insert(t){if(!this.boundary.contains(t))return!1;if(!this.divided){if(this.points.length<this.capacity||this.depth===this.MAX_DEPTH)return this.points.push(t),!0;this.subdivide()}return this.northeast.insert(t)||this.northwest.insert(t)||this.southeast.insert(t)||this.southwest.insert(t)}query(t,s){if(s||(s=[]),!t.intersects(this.boundary))return s;if(this.divided)return this.northwest.query(t,s),this.northeast.query(t,s),this.southwest.query(t,s),this.southeast.query(t,s),s;for(const e of this.points)t.contains(e)&&s.push(e);return s}deleteInRange(t){this.divided&&(this.northwest.deleteInRange(t),this.northeast.deleteInRange(t),this.southwest.deleteInRange(t),this.southeast.deleteInRange(t)),this.points=this.points.filter((s=>!t.contains(s)))}closest(t,s=1,e=1/0){if(void 0===t)throw TypeError("Method 'closest' needs a point");const i=e**2;return this.kNearest(t,s,i,0,0).found}kNearest(t,s,e,i,h){let n=[];return this.divided?this.children.sort(((s,e)=>s.boundary.sqDistanceFrom(t)-e.boundary.sqDistanceFrom(t))).forEach((r=>{const o=r.boundary.sqDistanceFrom(t);if(!(o>e)&&(h<s||o<i)){const o=r.kNearest(t,s,e,i,h),a=o.found;n=n.concat(a),h+=a.length,i=o.furthestSqDistance}})):this.points.sort(((s,e)=>s.sqDistanceFrom(t)-e.sqDistanceFrom(t))).forEach((r=>{const o=r.sqDistanceFrom(t);o>e||(h<s||o<i)&&(n.push(r),i=Math.max(o,i),h++)})),{found:n.sort(((s,e)=>s.sqDistanceFrom(t)-e.sqDistanceFrom(t))).slice(0,s),furthestSqDistance:Math.sqrt(i)}}forEach(t){this.divided?(this.northeast.forEach(t),this.northwest.forEach(t),this.southeast.forEach(t),this.southwest.forEach(t)):this.points.forEach(t)}filter(t){let s=new QuadTree(this.boundary,this.capacity);return this.forEach((e=>{t(e)&&s.insert(e)})),s}merge(t,s){let e=Math.min(this.boundary.left,t.boundary.left),i=Math.max(this.boundary.right,t.boundary.right),h=Math.min(this.boundary.top,t.boundary.top),n=Math.max(this.boundary.bottom,t.boundary.bottom)-h,r=i-e,o=new Rectangle(e+r/2,h+n/2,r,n),a=new QuadTree(o,s);return this.forEach((t=>a.insert(t))),t.forEach((t=>a.insert(t))),a}get length(){return this.divided?this.northwest.length+this.northeast.length+this.southwest.length+this.southeast.length:this.points.length}}"undefined"!=typeof module&&(module.exports={Point:Point,Rectangle:Rectangle,QuadTree:QuadTree,Circle:Circle});
//# sourceMappingURL=quadtree-min.js.map